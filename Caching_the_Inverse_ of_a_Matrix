# Matrix inversion is usually a costly computation and there may be some benefit
# to caching the inverse of a matrix rather than compute it repeatedly. The
# following two functions are used to cache the inverse of a matrix.
# makeCacheMatrix creates a list containing a function to
# 1. set the value of the matrix
# 2. get the value of the matrix
# 3. set the value of inverse of the matrix
# 4. get the value of inverse of the matrix

makeCacheMatrix <- function(x = matrix()) {
  inversa <- NULL 
  set <- function(y) { 
  x <<- y 
  inversa <<- NULL 
  } 
  get <- function() x 
  setInverse <- function(inverse) inversa <<- inverse 
  getInverse <- function() inversa 
  list(set = set, get = get, 
  setInverse = setInverse, 
  getInverse = getInverse) 
}

# The following function returns the inverse of the matrix. It first checks if
# the inverse has already been computed. If so, it gets the result and skips the
# computation. If not, it computes the inverse, sets the value in the cache via
# setinverse function.

# This function assumes that the matrix is always invertible.

cacheSolve <- function(x, ...) {
    ## Return a matrix that is the inverse of 'x'inversa <- x$getInverse() 
    if(!is.null(inversa)) { 
    message("getting cached data") 
    return(inversa) 
  } 
  data <- x$get() 
  inversa <- solve(data, ...) 
  x$setInverse(inversa) 
  inversa 
}

##sample matrix for testing
m1 <- matrix(c(1/2, -1/4, -1, 3/4), nrow = 2, ncol = 2)
m1
##       [,1]  [,2]
## [1,]  0.50 -1.00
## [2,] -0.25  0.75

myMatrix_object <- makeCacheMatrix(m1)
myMatrix_object
cacheSolve(myMatrix_object)
##getting cached data.
##       [,1] [,2]
## [1,]    6    8
## [2,]    2    4

